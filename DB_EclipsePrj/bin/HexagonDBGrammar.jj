/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options
{
  static = true;
  DEBUG_PARSER = false;
  IGNORE_CASE = true;
  LOOKAHEAD = 3;
  //FORCE_LA_CHECK =true;
}
PARSER_BEGIN(HexagonDBMSParser)
import com.sleepycat.je.*;
import com.sleepycat.je.Database;
import com.sleepycat.je.DatabaseException;
import com.sleepycat.je.DatabaseConfig;
import com.sleepycat.je.Cursor;

import com.sleepycat.je.Environment;
import com.sleepycat.je.EnvironmentConfig;

import java.io.*;


public class HexagonDBMSParser{

  public static final int PRINT_SYNTAX_ERROR = 0;
  public static final int PRINT_CREATE_TABLE = 1;
  public static final int PRINT_DROP_TABLE = 2;
  public static final int PRINT_DESC = 3;
  public static final int PRINT_INSERT = 4;
  public static final int PRINT_DELETE = 5;
  public static final int PRINT_SELECT = 6;
  public static final int PRINT_SHOW_TABLES = 7;
    public static void main(String args []) throws ParseException  {
    HexagonDBMSParser parser = new HexagonDBMSParser(System.in);
    
	//
	Environment hexaEnv = null;
	Database hexaDB = null;


	EnvironmentConfig envConf = new EnvironmentConfig();
	envConf.setAllowCreate(true);
	hexaEnv = new Environment(new File("db/"),envConf);

	DatabaseConfig dbConf = new DatabaseConfig();
	dbConf.setAllowCreate(true);
	dbConf.setSortedDuplicates(true);
	hexaDB = hexaEnv.openDatabase(null,"sampleDatabase",dbConf);

	/*
	//db insert
	Cursor cur = null;
	DatabaseEntry key;
	DatabaseEntry data;

	try {
	  cur=hexaDB.openCursor(null,null);
	  key= new DatabaseEntry("key".getBytes("UTF-8"));
	  data= new DatabaseEntry("data".getBytes("UTF-8"));
	  cur.put(key,data);
	}
	catch(DatabaseException de) {
	}
	catch(UnsupportedEncodingException e) {
	  e.printStackTrace();
	}


	//db search
	DatabaseEntry foundKey = new DatabaseEntry();
	DatabaseEntry foundData = new DatabaseEntry();

	cur.getFirst(foundKey,foundData,LockMode.DEFAULT);
	do {
	  String keyString = new String(foundKey.getData(),"UTF-8");
	  String dataString = new String(foundData.getData(),"UTF-8");
	}while(cur.getNext(foundKey,foundData,LockMode.DEFAULT) == OperationStatus.SUCCESS);
	*/



       while (true)
    {
      System.out.print("HexagonDB_2012-11253> ");      try
      {
        if(!parser.command()){
          if(hexaDB != null) hexaDB.close();
          if(hexaEnv != null) hexaEnv.close();
        }
        	      }      catch (Exception e)
      {        printMessage(PRINT_SYNTAX_ERROR);
        e.printStackTrace();
        HexagonDBMSParser.ReInit(System.in);      }      catch (Error e)      {        System.out.println("Oops.");        System.out.println(e.getMessage());        break;      }    }  }
  
  public static void printMessage(int q)
  {
    switch(q)
    {
      case PRINT_SYNTAX_ERROR:
      	System.out.println("Syntax error");
      	break;
      case PRINT_CREATE_TABLE:
      	System.out.println("\'CREATE TABLE\' requested");
      	break;
      case PRINT_DROP_TABLE :
      	System.out.println("\'DROP TABLE\' requested");
      	break;
      case PRINT_DESC:
      	System.out.println("\'DESC\' requested");
      	break; 
      case PRINT_INSERT:
      	System.out.println("\'INSERT\' requested");
      	break; 
      case PRINT_DELETE:
      	System.out.println("\'DELETE\' requested");
      	break; 
      case PRINT_SELECT:
      	System.out.println("\'SELECT\' requested");
      	break; 
      case PRINT_SHOW_TABLES:
      	System.out.println("\'SHOW TABLES\' requested");
      	break; 
    }
  }}PARSER_END(HexagonDBMSParser)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN : /* Keywords */
{
  < EXIT : "exit" >
| < INT : "int" >
| < CHAR : "char" >
| < DATE : "date" >
| < CREATE_TABLE : "create table" >
| < DROP_TABLE : "drop table" >
| < DESC : "desc" >
| < INSERT_INTO : "insert into" >
| < DELETE_FROM : "delete from" >
| < SELECT : "select" >
| < SHOW_TABLES : "show tables" >
| < NOT_NULL : "not null" >
| < PRIMARY_KEY : "primary key" >
| < FOREIGN_KEY : "foreign key" >
| < REFERENCES : "references" >
| < VALUES : "values" >
| < WHERE : "where" >
| < AND : "and" >
| < OR : "or" >
| < IS : "is" >
| < NULL : "null" >
| < NOT : "not" >
| < FROM : "from" >
| < AS : "as" >
| < ASTERISK : "*" >
}

TOKEN :
{
    < SEMICOLON : ";" >
| < LEFT_PAREN : "(" >
| < RIGHT_PAREN : ")" >
| < COMMA : "," >
| < UNDERSCORE : "_" >
| < INT_VALUE : (< SIGN >)? (< DIGIT >)+>
| < SIGN : "+" | "-" >
| < DIGIT : [ "0"-"9" ] >
| < LEGAL_IDENTIFIER : < ALPHABET >(< ALPHABET > | < UNDERSCORE >)* >
| < ALPHABET : [ "a"-"z", "A"-"Z" ] >
| < SPACE : " "|"\t" >
| < EQUAL : "=" >
| < COMP_OP : < EQUAL >|"<"|">"|">="|"<="|"!=" >
| < QUOTE : "\'" >
| < PERIOD : "." >
| < NON_QUOTE_SPECIAL_CHARACTERS : "!"|"@"|"#"|"$"|"%"|"^"|"&"|"*"|"("|")"|":"|";"|"<"|">"|"?"|"/" >
| < DATE_HYPON : " - " >
| < CHAR_STRING : < QUOTE >< NON_QUOTE_CHARACTER >< QUOTE >>
| < NON_QUOTE_CHARACTER : < DIGIT >|< ALPHABET >|< NON_QUOTE_SPECIAL_CHARACTERS >|< SPACE >>
| < NN : < DIGIT >< DIGIT >>
| < NNNN : < NN >< NN >>
| < DATE_VALUE : < NNNN >" - "< NN >" - "< NN >> 
}



boolean command() :
{}
{
  (    queryList()
      {
        return true;        
      })
  | (< EXIT >< SEMICOLON >
  	 {
          return false;
     }) 
}

void queryList() :
{
  int q;
}
{
  (q = query()< SEMICOLON >
    {
      printMessage(q);
    })+
}

int query() :
{
  int q;
}
{
  (    (
      createTableQuery()
   		{
      	q = PRINT_CREATE_TABLE;
    	}
    )
  	|(
  	  dropTableQuery()
  	  {
  	    q = PRINT_DROP_TABLE;
  	  }
  	)
  	|(
  	  descQuery()
  	  {
  	    q = PRINT_DESC;
  	  }
  	)
  	|(
  	  insertQuery()
  	  {
  	    q = PRINT_INSERT;
  	  }
  	)
  	|(
  	  deleteQuery()
  	  {
  	    q = PRINT_DELETE;
  	  }
  	)
  	|(
  	  selectQuery()
  	  {
  	    q = PRINT_SELECT;
  	  }
  	)  
  	|(
  	  showTablesQuery()
  	  {
  	    q = PRINT_SHOW_TABLES;
  	  }
  	)    
  )
  ({
    return q;
  })
}

//create table account (account_number int not null,branch_name char(15),primary key(account_number));

void createTableQuery() :
{}
{
  < CREATE_TABLE >
  tableName()
  tableElementList()
}

void tableElementList() :
{}
{
  < LEFT_PAREN >
  tableElement()
  (
    < COMMA >
    tableElement()
  )*
  < RIGHT_PAREN >
}

void tableElement() :
{
}
{
  columnDefinition()
| tableConstraintDefinition()
}

void columnDefinition() :
{}
{
  columnName()
  dataType()
  (
    < NOT_NULL >
  )?
}

void tableConstraintDefinition() :
{}
{
  primaryKeyConstraint()
| referentialConstraint()
}

void primaryKeyConstraint() :
{}
{
  < PRIMARY_KEY >
  columnNameList()
}

void referentialConstraint() :
{}
{
  < FOREIGN_KEY >
  columnNameList()
  < REFERENCES >
  tableName()
  columnNameList()
}

void columnNameList() :
{}
{
  < LEFT_PAREN >
  columnName()
  (
    < COMMA >
    columnName()
  )*
  < RIGHT_PAREN >
}

void dataType() :
{}
{
  < INT >
| (
    < CHAR >
    < LEFT_PAREN >
    < INT_VALUE >
    < RIGHT_PAREN >
  )
| < DATE >
}

void tableName() :
{}
{
  (    < LEGAL_IDENTIFIER >)*
}

void columnName() :
{}
{
  (    < LEGAL_IDENTIFIER >)*
}






//drop table account;
void dropTableQuery() :
{
}
{
  (
    < DROP_TABLE >
    tableName()
  )
}

//desc account;
void descQuery() :
{
}
{
  (
    < DESC >
    tableName()  )
}


//select customer_name, borrower.loan_number, amount from borrower, loan where borrower.loan_number = loan.loan_number and branch_name = 'Perryridge';
void selectQuery() :
{
}
{
  < SELECT >
  selectList()
  tableExpression()
}

void selectList() :
{
}
{
  (    ((selectedColumn()< COMMA >)*selectedColumn())
  	| < ASTERISK > 
  ) 
}

void selectedColumn() :
{
}
{
  (tableName()< PERIOD >)?columnName()(< AS >columnName())?
}

void tableExpression():
{
}
{
  fromClause()
  (whereClause())?
}

void fromClause() :
{
}
{
  < FROM >
  tableReferenceList()
}

void tableReferenceList() :
{
}
{
  referedTable()
  (< COMMA >referedTable())*
}


void referedTable():
{
}
{
  tableName()(< AS >tableName())?
}

void whereClause():
{
}
{
  < WHERE >
  booleanValueExpression()
}

void booleanValueExpression():
{
}
{
  booleanTerm()(< OR >booleanTerm())* 
}

void booleanTerm():
{
}
{
  booleanFactor()(< AND >booleanFactor())*
}

void booleanFactor():
{
}
{
  booleanTest()|< NOT >booleanTest()
}

void booleanTest():
{
}
{
  predicate()|parenthesizedBooleanExpression()  
}

void parenthesizedBooleanExpression():
{
}
{
  < LEFT_PAREN >
  booleanValueExpression()
  < RIGHT_PAREN >
}
void predicate():
{
}
{
  comparisonPredicate()|nullPredicate()
}

void comparisonPredicate():
{
}
{
  compOperand()
  (< COMP_OP >|< EQUAL >)
  compOperand()
}
	
void compOperand():
{
}
{
 ((tableName()< PERIOD >)?columnName())|comparableValue()
}

void comparableValue():
{
}
{
  < INT_VALUE >|< CHAR_STRING >|< DATE_VALUE >
}

void nullPredicate():
{
}
{
  (tableName()< PERIOD >)?columnName()nullOperation()
}
void nullOperation():
{
}
{
  < IS >(< NOT >)?< NULL >
}



void showTablesQuery() :
{
}
{
  < SHOW_TABLES >
}


//insert into account values(9732, 12345);
void insertQuery() :
{
}
{
  (
    < INSERT_INTO >
    tableName()
    insertColumnsAndSource()   
  )
}


void insertColumnsAndSource():
{
}
{
  (columnNameList())?valueList()
}

void valueList():
{
}
{
  < VALUES >
  < LEFT_PAREN >
  value()(< COMMA >value())*
  < RIGHT_PAREN >
}

void value():
{
}
{
  < NULL >|comparableValue()
}


//delete from account where branch_name = 'Perryridge';
void deleteQuery() :
{
}
{
  < DELETE_FROM >
  tableName()
  (whereClause())?
}



