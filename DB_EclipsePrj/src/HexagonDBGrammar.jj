/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options
{
  static = true;
  DEBUG_PARSER = false;
  IGNORE_CASE = true;
  LOOKAHEAD = 3;
  //FORCE_LA_CHECK =true;
}
PARSER_BEGIN(HexagonDBMSParser)
import com.sleepycat.je.*;
import com.sleepycat.je.Database;
import com.sleepycat.je.DatabaseException;
import com.sleepycat.je.DatabaseConfig;
import com.sleepycat.je.Cursor;

import com.sleepycat.je.Environment;
import com.sleepycat.je.EnvironmentConfig;

import java.io.*;
import java.util.*;


class pair {
  String type; //keyvalue
  String defined;

  public pair(String defined, String type) {
    this.defined = defined;
    this.type = type;
  }  
}

class tableElement{
  String[] element;
  String tableName;

  public tableElement(String[] ss,String tableName) {
    this.element = ss;
    this.tableName = tableName;
  }
  

  public pair define(){
    int len;
    String ret="";
    String type;
    if(element[0].equals("primary")) {
      type = "primary[["+tableName+"]]";
      len = element.length-1;
      ret = type+":"+element[1];
      for(int i=2;i<element.length;i++) {
        ret+="|"+element[i];
      }
    }
    else if(element[0].equals("foreign")) {
      String refTableName = element[1];
      len = element.length/2 -1;
      type = "foreign[["+tableName+"]]["+refTableName+"]";
      ret = type+":"+element[2]+"|"+element[3];
      for(int i=1;i<len;i++) {
        ret+="|=|"+element[i*2+2]+"|"+element[i*2+3];
      }
    }
    else {
      if(element.length!=4){
        //error - columnDef parsed incorrectly
        return null;
      }
      else {
        String colName = element[0];
        boolean isNull = (element[3].equals("null"));
        type = "column[["+tableName+"]]["+colName+"]";
        ret = type+"[";
        if(element[1].equals("int"))
          ret+="int]";
        else if(element[1].equals("char"))
          ret+="char("+element[2]+")]";
        else if(element[1].equals("date"))
          ret+="date]";
          if(isNull){
            ret+="[null]";
          }
          else{ 
            ret+="[not null]";
          }
      }
    }
    return new pair(ret,type);
  }
}



class StringResponse{
  public String syntaxError = "Syntax error";
  public String DuplicateColumnDefError = "Create table has failed: column definition is duplicated";
  public String DuplicatePrimaryKeyDefError = "Create table has failed: primary key definition is duplicated";
  public String ReferenceTypeError = "Create table has failed: foreign key references wrong type";
  public String ReferenceNonPrimaryKeyError = "Create table has failed: foreign key references non primary key columns non primary key column";
  public String ReferenceColumnExistenceError = "Create table has failed: foreign key references non existing column";
  public String ReferenceTableExistenceError = "Create table has failed: foreign key references non existing table";
  public String TableExistenceError = "Create table has failed: table with the same name already exists";
  public String ShowTablesNoTable = "There is no table";
  public String NoSuchTable = "No such table";
  public String CharLengthError = "Char length should be Char length should be over 0";
    
  public String CreateTableSuccess(String tableName) {
    return "'"+tableName+"'"+" table is created";
  }
  public String NonExistingColumnDefError(String colName) {
    return "Create table has failed: '"+colName+"' does not exists in column definition";
  }

  public String DropSuccess(String tableName) {
    return "'"+tableName+"' table is dropped";
  }
  public String DropReferencedTableError(String tableName) {
    return "Drop table has failed: '"+tableName+"' is referenced by other table";
  }
}


public class HexagonDBMSParser{

  public static final int PRINT_SYNTAX_ERROR = 0;
  public static final int PRINT_CREATE_TABLE = 1;
  public static final int PRINT_DROP_TABLE = 2;
  public static final int PRINT_DESC = 3;
  public static final int PRINT_INSERT = 4;
  public static final int PRINT_DELETE = 5;
  public static final int PRINT_SELECT = 6;
  public static final int PRINT_SHOW_TABLES = 7;

  public final StringResponse res = new StringResponse();

  private static Environment hexaEnv = null;
  private static Database hexaDB = null;

  private static void openDB(String dbName) {
	EnvironmentConfig envConf = new EnvironmentConfig();
	envConf.setAllowCreate(true);
	hexaEnv = new Environment(new File("db/"),envConf);

	DatabaseConfig dbConf = new DatabaseConfig();
	dbConf.setAllowCreate(true);
	dbConf.setSortedDuplicates(true);
	hexaDB = hexaEnv.openDatabase(null,dbName,dbConf);
	Cursor cur = null;
	DatabaseEntry key;
	DatabaseEntry data;

	try {
	  cur=hexaDB.openCursor(null,null);
	  key= new DatabaseEntry("tableList:".getBytes("UTF-8"));
	  data= new DatabaseEntry("".getBytes("UTF-8"));
	  cur.put(key,data);
	}
	catch(DatabaseException de) {
	}
	catch(UnsupportedEncodingException e) {
	  e.printStackTrace();
	}
  }

  private static void closeDB() {
    if(hexaDB != null) hexaDB.close();
    if(hexaEnv != null) hexaEnv.close();
  } 
    public static void main(String args []) throws ParseException  {
    HexagonDBMSParser parser = new HexagonDBMSParser(System.in);
    openDB("HexaDB");
	while (true)
    {
      System.out.print("HexagonDB_2012-11253> ");      try
      {
        if(!parser.command()){
          if(hexaDB != null) hexaDB.close();
          if(hexaEnv != null) hexaEnv.close();
        }
        	      }      catch (Exception e)
      {        printMessage(PRINT_SYNTAX_ERROR);
        e.printStackTrace();
        HexagonDBMSParser.ReInit(System.in);      }      catch (Error e)      {        System.out.println("Oops.");        System.out.println(e.getMessage());        break;      }    }  }
  
  public static void printMessage(int q)
  {
    switch(q)
    {
      case PRINT_SYNTAX_ERROR:
      	System.out.println("Syntax error");
      	break;
      case PRINT_CREATE_TABLE:
      	System.out.println("\'CREATE TABLE\' requested");
      	break;
      case PRINT_DROP_TABLE :
      	System.out.println("\'DROP TABLE\' requested");
      	break;
      case PRINT_DESC:
      	System.out.println("\'DESC\' requested");
      	break; 
      case PRINT_INSERT:
      	System.out.println("\'INSERT\' requested");
      	break; 
      case PRINT_DELETE:
      	System.out.println("\'DELETE\' requested");
      	break; 
      case PRINT_SELECT:
      	System.out.println("\'SELECT\' requested");
      	break; 
      case PRINT_SHOW_TABLES:
      	System.out.println("\'SHOW TABLES\' requested");
      	break; 
    }
  }

  public static void createTable(String name, ArrayList<tableElement > li) throws ParseException {//name = tableName, li = tableElements
    //printMessage(q);

    //manage data input
    pair[] elementsDefined = new pair[li.size()];
    ArrayList<String> columns = new ArrayList<String>();
    ArrayList<String> primary = new ArrayList<String>();
    ArrayList<String> foreign = new ArrayList<String>();

	//tableName Check
	Cursor cur = null;
	DatabaseEntry foundKey = new DatabaseEntry();
	DatabaseEntry foundData = new DatabaseEntry();
	String tableList="";
    try {
		cur.getFirst(foundKey,foundData,LockMode.DEFAULT);
		do {
	  	  String keyString = new String(foundKey.getData(),"UTF-8");
	      String dataString = new String(foundData.getData(),"UTF-8");
	      if(!keyString.equals("tableList:")) 
	      	continue;
	      else{
	        tableList = dataString;
	      }
		}while(cur.getNext(foundKey,foundData,LockMode.DEFAULT) == OperationStatus.SUCCESS);
	}
	catch(DatabaseException de) {
	}
	catch(UnsupportedEncodingException e) {
	  e.printStackTrace();
	}

	

    //columns check
    for(int i=0;i<li.size();i++) {
      tableElement t = li.get(i);
      elementsDefined[i]=t.define();
      if(elementsDefined[i].type.substring(0,6).equals("column")) {
        String tempName = elementsDefined[i].type.substring(elementsDefined[i].type.indexOf("["),elementsDefined[i].type.indexOf("]")+1);
        if(columns.contains(tempName)){ 
          //DuplicateColumnDefError
        }
        else {
          columns.add(tempName);
        }         
      }
    }

    //constraint check
    for(int i=0;i<elementsDefined.length;i++) {
      boolean primaryExists = false;
      
      pair t = elementsDefined[i];
      if(t.type.substring(0,6).equals("primar")) {
        if(primaryExists) {
          //DuplicatePrimaryKeyError
        }
        else primaryExists = true;
        
        String[] primaryColumns = t.defined.substring(8,t.defined.length()).split("|");
        for(int j=0;j<primaryColumns.length;j++) {
          if(!columns.contains(primaryColumns[j])) { 
            //NonExistingColumnDefError(#colName)
          }
          else
            primary.add(primaryColumns[j]);
        }
      }
      else if(t.type.substring(0,6).equals("foreig")) {
        //1. ReferenceTableExistenceError

        //2. ReferenceColumnExistenceError

        //3. ReferenceNonPrimaryKeyError
      }
      else continue;
    }

	//db insert
	DatabaseEntry key;
	DatabaseEntry data;

	try {
	  cur=hexaDB.openCursor(null,null);
	  for(int i=0;i<li.size();i++) {
	    key= new DatabaseEntry(("{"+name+"}"+elementsDefined[i].type).getBytes("UTF-8"));
	    data= new DatabaseEntry(elementsDefined[i].defined.getBytes("UTF-8"));
	    cur.put(key,data);
	  }
	}
	catch(DatabaseException de) {
	}
	catch(UnsupportedEncodingException e) {
	  e.printStackTrace();
	}
  }
  
  public static void dropTable(String name) throws ParseException{
    //db search
	Cursor cur = null;
	DatabaseEntry foundKey = new DatabaseEntry();
	DatabaseEntry foundData = new DatabaseEntry();

	try {
		cur.getFirst(foundKey,foundData,LockMode.DEFAULT);
		do {
	  	  String keyString = new String(foundKey.getData(),"UTF-8");
	      String dataString = new String(foundData.getData(),"UTF-8");
	      if(!keyString.substring(1,keyString.indexOf("}")).equals(name)) { 
	      	continue;
	      }
	      else{
	      }	      
		}while(cur.getNext(foundKey,foundData,LockMode.DEFAULT) == OperationStatus.SUCCESS);
	}
	catch(DatabaseException de) {
	}
	catch(UnsupportedEncodingException e) {
	  e.printStackTrace();
	}
  }
  
  
  public static void desc(String name) throws ParseException {
    //db search
	Cursor cur = null;
	DatabaseEntry foundKey = new DatabaseEntry();
	DatabaseEntry foundData = new DatabaseEntry();
	boolean noSuchTable=true;
	ArrayList<String> retStrings = new ArrayList<String>();

	try {
		cur.getFirst(foundKey,foundData,LockMode.DEFAULT);
		do {
	  	  String keyString = new String(foundKey.getData(),"UTF-8");
	      String dataString = new String(foundData.getData(),"UTF-8");
	      if(!keyString.substring(1,keyString.indexOf("}")).equals(name)) 
	      	continue;
	      else{
	        noSuchTable = false;
	        retStrings.add(dataString);
	      }
		}while(cur.getNext(foundKey,foundData,LockMode.DEFAULT) == OperationStatus.SUCCESS);
	}
	catch(DatabaseException de) {
	}
	catch(UnsupportedEncodingException e) {
	  e.printStackTrace();
	}
	if(noSuchTable) {
	  //error
	}
	else {
	  //print retStrings in form
	}
  }
  public static void showTables() throws ParseException {
    //db search
	Cursor cur = null;
	DatabaseEntry foundKey = new DatabaseEntry();
	DatabaseEntry foundData = new DatabaseEntry();
	String tableList = "";

	try {
		cur.getFirst(foundKey,foundData,LockMode.DEFAULT);
		do {
	  	  String keyString = new String(foundKey.getData(),"UTF-8");
	      String dataString = new String(foundData.getData(),"UTF-8");
	      if(keyString.substring(0,10).equals("tableList:")){
	        tableList = dataString;
	      }
		}while(cur.getNext(foundKey,foundData,LockMode.DEFAULT) == OperationStatus.SUCCESS);
	}
	catch(DatabaseException de) {
	}
	catch(UnsupportedEncodingException e) {
	  e.printStackTrace();
	}
    if(tableList.equals("")) {
    }
    else {
    }
  }}PARSER_END(HexagonDBMSParser)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN : /* Keywords */
{
  < EXIT : "exit" >
| < INT : "int" >
| < CHAR : "char" >
| < DATE : "date" >
| < CREATE_TABLE : "create table" >
| < DROP_TABLE : "drop table" >
| < DESC : "desc" >
| < INSERT_INTO : "insert into" >
| < DELETE_FROM : "delete from" >
| < SELECT : "select" >
| < SHOW_TABLES : "show tables" >
| < NOT_NULL : "not null" >
| < PRIMARY_KEY : "primary key" >
| < FOREIGN_KEY : "foreign key" >
| < REFERENCES : "references" >
| < VALUES : "values" >
| < WHERE : "where" >
| < AND : "and" >
| < OR : "or" >
| < IS : "is" >
| < NULL : "null" >
| < NOT : "not" >
| < FROM : "from" >
| < AS : "as" >
| < ASTERISK : "*" >
}

TOKEN :
{
    < SEMICOLON : ";" >
| < LEFT_PAREN : "(" >
| < RIGHT_PAREN : ")" >
| < COMMA : "," >
| < UNDERSCORE : "_" >
| < INT_VALUE : (< SIGN >)? (< DIGIT >)+>
| < SIGN : "+" | "-" >
| < DIGIT : [ "0"-"9" ] >
| < LEGAL_IDENTIFIER : < ALPHABET >(< ALPHABET > | < UNDERSCORE >)* >
| < ALPHABET : [ "a"-"z", "A"-"Z" ] >
| < SPACE : " "|"\t" >
| < EQUAL : "=" >
| < COMP_OP : < EQUAL >|"<"|">"|">="|"<="|"!=" >
| < QUOTE : "\'" >
| < PERIOD : "." >
| < NON_QUOTE_SPECIAL_CHARACTERS : "!"|"@"|"#"|"$"|"%"|"^"|"&"|"*"|"("|")"|":"|";"|"<"|">"|"?"|"/" >
| < DATE_HYPON : " - " >
| < CHAR_STRING : < QUOTE >< NON_QUOTE_CHARACTER >< QUOTE >>
| < NON_QUOTE_CHARACTER : < DIGIT >|< ALPHABET >|< NON_QUOTE_SPECIAL_CHARACTERS >|< SPACE >>
| < NN : < DIGIT >< DIGIT >>
| < NNNN : < NN >< NN >>
| < DATE_VALUE : < NNNN >" - "< NN >" - "< NN >> 
}



boolean command() :
{}
{
  (    queryList()
      {
        return true;        
      })
  | (< EXIT >< SEMICOLON >
  	 {
          return false;
     }) 
}

void queryList() :
{
  int q;
}
{
  (q = query()< SEMICOLON >
    {
      printMessage(q);
    })+
}

int query() :
{
  int q;
}
{
  (    (
      createTableQuery()
      {
        q = PRINT_CREATE_TABLE;
	  }
    )
  	|(
  	  dropTableQuery()
  	  {
  	    q = PRINT_DROP_TABLE;
  	  }
  	)
  	|(
  	  descQuery()
  	  {
  	    q = PRINT_DESC;
  	  }
  	)
  	|(
  	  insertQuery()
  	  {
  	    q = PRINT_INSERT;
  	  }
  	)
  	|(
  	  deleteQuery()
  	  {
  	    q = PRINT_DELETE;
  	  }
  	)
  	|(
  	  selectQuery()
  	  {
  	    q = PRINT_SELECT;
  	  }
  	)  
  	|(
  	  showTablesQuery()
  	  {
  	    q = PRINT_SHOW_TABLES;
  	  }
  	)    
  )
  ({
    return q;
  })
}

//create table account (account_number int not null,branch_name char(15),primary key(account_number));

void createTableQuery() :
{
  String name;
  ArrayList<tableElement > li;
}
{
  < CREATE_TABLE >
  name = tableName()
  li = tableElementList()
  {
    createTable(name,li);
  }
}

ArrayList<tableElement > tableElementList() :
{
  ArrayList<tableElement > li;
  tableElement t;
}
{
  {
    li = new ArrayList<tableElement >();
  }
  < LEFT_PAREN >
  t=tableElement()
  {
    li.add(t);
  }
  (
    < COMMA >
    t=tableElement()
    {
      li.add(t);
    }
  )*
  < RIGHT_PAREN >
  {
  	return li;
  }
}

tableElement tableElement() :
{
  String[] ss;
}
{
  ss=columnDefinition()
| ss=tableConstraintDefinition()
	{
	  return new tableElement(ss,"");
	}

}

String[] columnDefinition() :
{
  String[] ret;
  String s;
  Token[] ss;
  boolean b;
  Token t;
}
{
  {
    t=null;
    b = false;
    ret = new String[4]; 
  }
  s=columnName()
  ss=dataType()
  (
    t=< NOT_NULL >
  )?
  {
    
  	if(t != null)
  		b = true;
  	ret[0] = s;
  	ret[1] = ss[0].image;
  	if(ss[1]!=null)
  		ret[2] = ss[1].image;
  	else
  		ret[2] = "";
  	if(b) {
	    ret[3] = "not null"; 
  	}
  	else ret[3] = "null";

  	return ret;
  }
}

String[] tableConstraintDefinition() :
{
  String[] ret;
}
{
  ret = primaryKeyConstraint()
| ret = referentialConstraint()
{
  return ret;
}
}

String[] primaryKeyConstraint() :
{
  String[] ret;
  String[] s;
}
{
  < PRIMARY_KEY >
  s = columnNameList()
  {
    ret = new String[s.length+1];
    ret[0] = "primary";
    for(int i=0;i<s.length;i++) {
      ret[i+1] = s[i];
    }
    return ret;
  }
}

String[] referentialConstraint() :
{
  String[] ret;
  String[] refNameList;
  String[] realNameList;
  String tName;
 // String 
}
{
  < FOREIGN_KEY >
  refNameList = columnNameList()
  < REFERENCES >
  tName = tableName()
  realNameList = columnNameList()
  {
    if(refNameList.length!=realNameList.length) {
      //referenceTypeError
    }
    ret = new String[(refNameList.length+1)*2];
    ret[0] = "foreign";
    ret[1] = tName;
    for(int i=1;i<=refNameList.length;i++){
      ret[2*i] = refNameList[i-1];
      ret[2*i+1] = realNameList[i-1];
    }
    return ret;
  }
}

String[] columnNameList() :
{
  ArrayList<String > ret;
  String s;
}
{
  {
    ret = new ArrayList<String >();
  }
  < LEFT_PAREN >
  s=columnName()
  {
    ret.add(s);
  }
  (
    < COMMA >
    s=columnName()
    {
      ret.add(s);
    }
  )*
  < RIGHT_PAREN >
  {
    return (String[])ret.toArray(new String[0]);
  }
}

Token[] dataType() :
{
  Token[] ret;
}
{
  {
    ret = new Token[2];
  }
 (
  
  ret[0]=< INT >
  {
    ret[1] = null;
  }
| (
    ret[0]=< CHAR >
    < LEFT_PAREN >
    ret[1]=< INT_VALUE >
    < RIGHT_PAREN >
  )
| ret[0]=< DATE >
	{
	  ret[1] = null;
	}
 )
 {
   return ret;
 }
}

String tableName() :
{
  String s;
  Token t;
}
{
  {
    s = "";
  }
  (
    t=< LEGAL_IDENTIFIER >
    {
      s+=t.image;
    }
  )*
  {
    return s;
  }
}

String columnName() :
{
  String s;
  Token t;
}
{
  {
    s = "";
  }
  (
    t=< LEGAL_IDENTIFIER >
    {
      s+=t.image;
    }
  )*
  {
    return s;
  }
}






//drop table account;
void dropTableQuery() :
{
  String name;
}
{
  < DROP_TABLE >
  name=tableName()
  {
    dropTable(name);
  }
}

//desc account;
void descQuery() :
{
  String name;
}
{
  < DESC >
  name=tableName()	
  {
    desc(name);
  }
}


//select customer_name, borrower.loan_number, amount from borrower, loan where borrower.loan_number = loan.loan_number and branch_name = 'Perryridge';
void selectQuery() :
{
}
{
  < SELECT >
  selectList()
  tableExpression()
}

void selectList() :
{
}
{
  (    ((selectedColumn()< COMMA >)*selectedColumn())
  	| < ASTERISK > 
  ) 
}

void selectedColumn() :
{
}
{
  (tableName()< PERIOD >)?columnName()(< AS >columnName())?
}

void tableExpression():
{
}
{
  fromClause()
  (whereClause())?
}

void fromClause() :
{
}
{
  < FROM >
  tableReferenceList()
}

void tableReferenceList() :
{
}
{
  referedTable()
  (< COMMA >referedTable())*
}


void referedTable():
{
}
{
  tableName()(< AS >tableName())?
}

void whereClause():
{
}
{
  < WHERE >
  booleanValueExpression()
}

void booleanValueExpression():
{
}
{
  booleanTerm()(< OR >booleanTerm())* 
}

void booleanTerm():
{
}
{
  booleanFactor()(< AND >booleanFactor())*
}

void booleanFactor():
{
}
{
  booleanTest()|< NOT >booleanTest()
}

void booleanTest():
{
}
{
  predicate()|parenthesizedBooleanExpression()  
}

void parenthesizedBooleanExpression():
{
}
{
  < LEFT_PAREN >
  booleanValueExpression()
  < RIGHT_PAREN >
}
void predicate():
{
}
{
  comparisonPredicate()|nullPredicate()
}

void comparisonPredicate():
{
}
{
  compOperand()
  (< COMP_OP >|< EQUAL >)
  compOperand()
}
	
void compOperand():
{
}
{
 ((tableName()< PERIOD >)?columnName())|comparableValue()
}

void comparableValue():
{
}
{
  < INT_VALUE >|< CHAR_STRING >|< DATE_VALUE >
}

void nullPredicate():
{
}
{
  (tableName()< PERIOD >)?columnName()nullOperation()
}
void nullOperation():
{
}
{
  < IS >(< NOT >)?< NULL >
}



void showTablesQuery() :
{
}
{
  < SHOW_TABLES >
  {
    showTables();
  }
}


//insert into account values(9732, 12345);
void insertQuery() :
{
}
{
  (
    < INSERT_INTO >
    tableName()
    insertColumnsAndSource()   
  )
}


void insertColumnsAndSource():
{
}
{
  (columnNameList())?valueList()
}

void valueList():
{
}
{
  < VALUES >
  < LEFT_PAREN >
  value()(< COMMA >value())*
  < RIGHT_PAREN >
}

void value():
{
}
{
  < NULL >|comparableValue()
}


//delete from account where branch_name = 'Perryridge';
void deleteQuery() :
{
}
{
  < DELETE_FROM >
  tableName()
  (whereClause())?
}



